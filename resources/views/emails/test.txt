#include <ESP32Servo.h>

// ===== PIN DEFINITIONS =====
#define WATER_SENSOR 27
#define RELAY_PIN    26
#define SERVO_PIN    14
#define A7670E_RX    16  // ESP32 RX â† A7670E TX
#define A7670E_TX    17  // ESP32 TX â†’ A7670E RX
#define A7670E_PWR   25  // Power key pin

// ===== SERIAL PORT =====
HardwareSerial a7670e(1);  // Using Serial1 for A7670E
Servo myServo;

// ===== CONFIGURATION =====
String phoneNumber = "+639070653250";

// ===== LOGIC VARIABLES =====
bool triggered = false;
bool pumpRunning = false;
bool servoRunning = false;
bool smsSent = false;
unsigned long pumpStartTime = 0;
unsigned long servoStartTime = 0;
unsigned long detectionTime = 0;
const unsigned long PUMP_DURATION = 10000;  // 10 seconds

// ===== GPS LOCATION VARIABLES =====
String latStr = "";
String lngStr = "";
String timeStr = "";

// ===== HELPER FUNCTION: Wait for A7670E response =====
String waitForResponse(int timeout = 2000) {
  String response = "";
  unsigned long start = millis();
  while (millis() - start < timeout) {
    while (a7670e.available()) {
      char c = a7670e.read();
      response += c;
      Serial.write(c);
    }
  }
  Serial.println();
  return response;
}

// ===== FORMAT GPS TIME TO PHILIPPINE TIME =====
String formatGPSTime(String utc) {
  // utc format: 20240124071530.000 (YYYYMMDDHHMMSS.sss)
  if (utc.length() < 14) {
    Serial.println("âš ï¸ Invalid GPS time format");
    return "Time unavailable";
  }
  
  String year = utc.substring(0, 4);
  String month = utc.substring(4, 6);
  String day = utc.substring(6, 8);
  String hour = utc.substring(8, 10);
  String minute = utc.substring(10, 12);
  String second = utc.substring(12, 14);
  
  // Convert to Philippine Time (UTC+8)
  int hr = hour.toInt() + 8;
  int dy = day.toInt();
  int mn = month.toInt();
  int yr = year.toInt();
  
  // Handle day rollover
  if (hr >= 24) {
    hr -= 24;
    dy++;
    
    // Days in each month (non-leap year, good enough for this application)
    int daysInMonth[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    
    // Check for leap year
    if ((yr % 4 == 0 && yr % 100 != 0) || (yr % 400 == 0)) {
      daysInMonth[1] = 29;
    }
    
    // Handle month rollover
    if (dy > daysInMonth[mn - 1]) {
      dy = 1;
      mn++;
      
      // Handle year rollover
      if (mn > 12) {
        mn = 1;
        yr++;
      }
    }
  }
  
  String monthNames[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
  String monthName = (mn >= 1 && mn <= 12) ? monthNames[mn - 1] : month;
  
  char timeBuffer[30];
  sprintf(timeBuffer, "%02d:%s:%s", hr, minute.c_str(), second.c_str());
  
  char dayBuffer[3];
  sprintf(dayBuffer, "%02d", dy);
  
  return monthName + " " + String(dayBuffer) + ", " + String(yr) + " " + String(timeBuffer) + " PHT";
}

// ===== GET PHILIPPINE TIME FROM NETWORK (FALLBACK) =====
String getPhilippineTimeFromNetwork() {
  Serial.println("â° Getting network time (fallback)...");
  a7670e.println("AT+CCLK?");
  String timeResponse = waitForResponse(2000);
  
  // Parse AT+CCLK response: +CCLK: "24/01/25,15:30:45+32"
  int timeIdx = timeResponse.indexOf("+CCLK: \"");
  if (timeIdx >= 0) {
    String datetime = timeResponse.substring(timeIdx + 8);
    int endQuote = datetime.indexOf("\"");
    if (endQuote > 0) {
      datetime = datetime.substring(0, endQuote);
      
      // Extract year and validate
      String yearStr = "20" + datetime.substring(0, 2);
      int year = yearStr.toInt();
      
      // Check if year is unreasonable (before 2024 or after 2030)
      if (year < 2024 || year > 2030) {
        Serial.println("âš ï¸ Invalid network time (year: " + String(year) + ")");
        return "[Time unavailable]";
      }
      
      int commaPos = datetime.indexOf(',');
      if (commaPos > 0) {
        String date = datetime.substring(0, commaPos);  // YY/MM/DD
        String time = datetime.substring(commaPos + 1); // HH:MM:SS+TZ
        
        // Remove timezone part
        int plusPos = time.indexOf('+');
        if (plusPos > 0) {
          time = time.substring(0, plusPos);
        }
        
        String month = date.substring(3, 5);
        String day = date.substring(6, 8);
        
        // Convert month number to name
        String monthNames[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                               "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
        int monthNum = month.toInt() - 1;
        String monthName = (monthNum >= 0 && monthNum < 12) ? monthNames[monthNum] : month;
        
        return monthName + " " + day + ", " + yearStr + " " + time + " PHT";
      }
    }
  }
  
  Serial.println("âš ï¸ Could not get network time");
  return "[Time unavailable]";
}

// ===== POWER ON A7670E MODULE =====
void powerOnA7670E() {
  Serial.println("ğŸ”Œ Powering on A7670E module...");
  pinMode(A7670E_PWR, OUTPUT);
  
  // Power on sequence: pull low for 1 second
  digitalWrite(A7670E_PWR, HIGH);
  delay(500);
  digitalWrite(A7670E_PWR, LOW);
  delay(1000);
  digitalWrite(A7670E_PWR, HIGH);
  delay(2000);
  
  Serial.println("â³ Waiting for module to boot...");
  delay(5000);  // Wait for module to fully boot
}

// ===== GET GPS LOCATION AND TIME =====
bool getGPSLocation() {
  Serial.println("\nğŸ›°ï¸ Getting GNSS location and time...");

  a7670e.println("AT+CGNSPWR=1");
  String r1 = waitForResponse(2000);
  if (r1.indexOf("ERROR") >= 0) {
    Serial.println("âŒ GNSS not supported (AT+CGNSPWR=1 returned ERROR).");
    Serial.println("ğŸ‘‰ Your A7670E board likely has NO GPS. You need an external GPS module (NEO-6M/M8N).");
    return false;
  }

  // Try multiple times to get a fix
  for (int i = 0; i < 30; i++) {
    Serial.printf("GNSS attempt %d/30...\n", i + 1);

    a7670e.println("AT+CGNSINF");
    String resp = waitForResponse(2000);

    int p = resp.indexOf("+CGNSINF:");
    if (p < 0) { delay(1000); continue; }

    // Example +CGNSINF: 1,1,20240124071530.000,14.5995,120.9842,....
    String line = resp.substring(p);
    int colon = line.indexOf(':');
    if (colon < 0) { delay(1000); continue; }

    String data = line.substring(colon + 1);
    data.trim();

    // split by commas (very basic)
    int idx1 = data.indexOf(',');                  // run status
    int idx2 = data.indexOf(',', idx1 + 1);        // fix status
    int idx3 = data.indexOf(',', idx2 + 1);        // UTC
    int idx4 = data.indexOf(',', idx3 + 1);        // lat
    int idx5 = data.indexOf(',', idx4 + 1);        // lon

    if (idx5 < 0) { delay(1000); continue; }

    String runStatus = data.substring(0, idx1);                 runStatus.trim();
    String fixStatus = data.substring(idx1 + 1, idx2);          fixStatus.trim();
    String utc       = data.substring(idx2 + 1, idx3);          utc.trim();
    String lat       = data.substring(idx3 + 1, idx4);          lat.trim();
    String lon       = data.substring(idx4 + 1, idx5);          lon.trim();

    if (fixStatus == "1" && lat.length() > 0 && lon.length() > 0 && lat != "0.0" && lon != "0.0") {
      latStr = lat;
      lngStr = lon;
      
      // Parse GPS UTC time and convert to Philippine Time
      if (utc.length() >= 14) {
        timeStr = formatGPSTime(utc);
        Serial.println("âœ… GPS TIME: " + timeStr);
      } else {
        Serial.println("âš ï¸ GPS time format invalid, trying network time...");
        timeStr = getPhilippineTimeFromNetwork();
      }

      Serial.println("âœ… GNSS FIX!");
      Serial.println("Lat: " + latStr);
      Serial.println("Lon: " + lngStr);
      Serial.println("Time: " + timeStr);
      return true;
    }

    Serial.println("No fix yet...");
    delay(2000);
  }

  Serial.println("âŒ No GNSS fix after attempts.");
  return false;
}


// ===== SEND SMS =====
void sendSMS(String msg) {
  Serial.println("\nâ¡ï¸ Sending SMS...");
  
  // Clear any pending data
  delay(500);
  while (a7670e.available()) {
    a7670e.read();
  }
  delay(500);
  
  Serial.print("AT: ");
  a7670e.print("AT\r\n");
  delay(500);
  waitForResponse(1000);
  
  Serial.print("Set text mode: ");
  a7670e.print("AT+CMGF=1\r\n");
  delay(500);
  waitForResponse(1000);
  
  Serial.print("Character set: ");
  a7670e.print("AT+CSCS=\"GSM\"\r\n");
  delay(500);
  waitForResponse(1000);
  
  Serial.print("Signal: ");
  a7670e.print("AT+CSQ\r\n");
  delay(500);
  waitForResponse(1000);
  
  Serial.print("Network: ");
  a7670e.print("AT+CREG?\r\n");
  delay(500);
  waitForResponse(2000);
  
  // Clear buffer again before sending SMS command
  while (a7670e.available()) {
    a7670e.read();
  }
  delay(500);
  
  Serial.println("\nSending SMS to: " + phoneNumber);
  Serial.println("Command: AT+CMGS=\"" + phoneNumber + "\"");
  
  // Send SMS command character by character to avoid buffer issues
  a7670e.print("AT+CMGS=\"");
  delay(100);
  a7670e.print(phoneNumber);
  delay(100);
  a7670e.print("\"\r\n");
  
  Serial.println("Waiting for '>' prompt...");
  delay(2000);
  
  // Check for '>' prompt
  bool promptReceived = false;
  String promptResponse = "";
  unsigned long promptWait = millis();
  
  while (millis() - promptWait < 5000) {  // Increased timeout
    if (a7670e.available()) {
      char c = a7670e.read();
      Serial.write(c);
      promptResponse += c;
      
      if (c == '>') {
        promptReceived = true;
        Serial.println("\nâœ… Prompt '>' received!");
        break;
      }
    }
    delay(10);
  }
  
  if (!promptReceived) {
    Serial.println("\nâŒ No prompt received!");
    Serial.println("Response was: " + promptResponse);
    Serial.println("Aborting SMS...");
    a7670e.write(27);  // Send ESC to cancel
    delay(500);
    return;
  }
  
  delay(500);
  Serial.println("Sending message content...");
  
  // Send message character by character
  for (unsigned int i = 0; i < msg.length(); i++) {
    a7670e.write(msg[i]);
    Serial.write(msg[i]);
    delay(10);  // Small delay between characters
  }
  
  delay(500);
  
  // Send Ctrl+Z to finish
  Serial.println("\n\nSending Ctrl+Z...");
  a7670e.write(26);
  
  Serial.println("ğŸ“¤ Waiting for SMS delivery confirmation...");
  
  // Wait for response
  String response = "";
  unsigned long sendStart = millis();
  
  while (millis() - sendStart < 30000) {  // 30 second timeout
    while (a7670e.available()) {
      char c = a7670e.read();
      response += c;
      Serial.write(c);
    }
    
    // Check if SMS was sent successfully
    if (response.indexOf("+CMGS:") >= 0) {
      Serial.println("\n\nâœ… SMS SENT SUCCESSFULLY!");
      return;
    } else if (response.indexOf("ERROR") >= 0) {
      Serial.println("\n\nâŒ SMS FAILED - Error from module!");
      Serial.println("Response: " + response);
      return;
    }
    
    delay(100);
  }
  
  Serial.println("\nâš ï¸ SMS status unknown (timeout after 30s)");
  Serial.println("Last response: " + response);
}

// ===== SETUP =====
void setup() {
  pinMode(WATER_SENSOR, INPUT);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, HIGH);  // Relay OFF initially
  
  Serial.begin(115200);
  delay(1000);
  Serial.println("\n\n========================================");
  Serial.println("  FLOOD DETECTION SYSTEM + A7670E");
  Serial.println("========================================\n");
  
  // Power on A7670E
  powerOnA7670E();
  
  // Initialize A7670E Module
  Serial.println("ğŸ“¡ Initializing A7670E...");
  a7670e.begin(115200, SERIAL_8N1, A7670E_RX, A7670E_TX);
  delay(2000);
  
  Serial.print("Testing module: ");
  a7670e.println("AT");
  waitForResponse(2000);
  
  Serial.print("Disable echo: ");
  a7670e.println("ATE0");
  waitForResponse(1000);
  
  Serial.print("Module info: ");
  a7670e.println("ATI");
  waitForResponse(2000);
  
  Serial.print("Checking SIM card: ");
  a7670e.println("AT+CPIN?");
  waitForResponse(2000);
  
  Serial.println("\nâ³ Waiting for network registration...");
  bool registered = false;
  
  for (int i = 0; i < 40; i++) {
    a7670e.println("AT+CREG?");
    delay(500);
    
    String response = waitForResponse(1000);
    
    if (response.indexOf("+CREG: 0,1") >= 0 || 
        response.indexOf("+CREG: 0,5") >= 0) {
      registered = true;
      Serial.println("âœ… Network registered!");
      break;
    }
    
    if (i % 5 == 0) {
      Serial.print("Still searching... (");
      Serial.print(i);
      Serial.println("/40)");
    }
    
    delay(1000);
  }
  
  if (!registered) {
    Serial.println("âš ï¸ Network registration timeout");
    Serial.println("   Check: SIM card inserted, has credit, antenna connected");
  }
  
  Serial.print("\nğŸ“¶ Signal strength: ");
  a7670e.print("AT+CSQ\r\n");
  waitForResponse(2000);
  Serial.println("   (Good signal: +CSQ: 10-31,0)");
  
  // Additional SMS setup checks
  Serial.println("\nğŸ“± SMS Configuration Checks:");
  
  Serial.print("SMS service center: ");
  a7670e.print("AT+CSCA?\r\n");
  waitForResponse(2000);
  
  Serial.print("Preferred message storage: ");
  a7670e.print("AT+CPMS=\"SM\",\"SM\",\"SM\"\r\n");
  waitForResponse(2000);
  
  Serial.print("SMS text mode: ");
  a7670e.print("AT+CMGF=1\r\n");
  waitForResponse(1000);
  
  Serial.print("Character set to GSM: ");
  a7670e.print("AT+CSCS=\"GSM\"\r\n");
  waitForResponse(1000);
  
  Serial.println("\nğŸ’¡ TROUBLESHOOTING TIPS:");
  Serial.println("   If SMS fails:");
  Serial.println("   1. Check signal strength (should be 10-31)");
  Serial.println("   2. Verify SIM has SMS credit/capability");
  Serial.println("   3. Test with AT+CMGS manually via Serial Monitor");
  Serial.println("   4. Some SIMs need service center number configured");
  
  // Test GPS
  Serial.println("\nğŸ›°ï¸ Testing GPS...");
  Serial.print("Enabling GPS: ");
  a7670e.println("AT+CGPS=1");
  waitForResponse(2000);
  
  Serial.println("\nâš ï¸ GPS NOTES:");
  Serial.println("   â€¢ Needs clear sky view (won't work indoors)");
  Serial.println("   â€¢ First fix takes 1-5 minutes outdoors");
  Serial.println("   â€¢ GPS antenna must be connected properly");
  Serial.println("   â€¢ GPS time will be used for accurate timestamps");
  
  // Initialize Servo
  Serial.println("\nğŸ”§ Initializing servo...");
  myServo.setPeriodHertz(50);
  myServo.attach(SERVO_PIN, 500, 2400);
  myServo.write(0);  // Start at 0 degrees
  delay(500);
  
  Serial.println("\n========================================");
  Serial.println("âœ… SYSTEM READY!");
  Serial.println("========================================");
  Serial.println("Monitoring for water detection...\n");
}

// ===== LOOP =====
void loop() {
  int waterDetected = digitalRead(WATER_SENSOR);
  
  // Status update every 10 seconds (only when not triggered)
  static unsigned long lastPrint = 0;
  if (!triggered && millis() - lastPrint > 10000) {
    Serial.print("ğŸ’§ Water: ");
    Serial.println(waterDetected == HIGH ? "âš ï¸ DETECTED" : "Normal");
    lastPrint = millis();
  }
  
  // ===== WATER DETECTION TRIGGER =====
  if (waterDetected == HIGH && !triggered) {
    Serial.println("\n");
    Serial.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Serial.println("â•‘   ğŸš¨ WATER DETECTED! ğŸš¨           â•‘");
    Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    Serial.println();
    
    triggered = true;
    pumpRunning = true;
    pumpStartTime = millis();
    detectionTime = millis();
    
    // STEP 1: Activate pump
    digitalWrite(RELAY_PIN, LOW);
    Serial.println("ğŸ”Œ STEP 1: Pump ACTIVATED (10 seconds)");
    Serial.println();
  }
  
  // ===== STEP 2: After 10 seconds, turn off pump and start servo =====
  if (pumpRunning && millis() - pumpStartTime >= PUMP_DURATION) {
    pumpRunning = false;
    servoRunning = true;
    servoStartTime = millis();
    
    // Turn off pump
    digitalWrite(RELAY_PIN, HIGH);
    Serial.println("ğŸ”Œ Pump: DEACTIVATED (10 seconds complete)");
    Serial.println();
    Serial.println("ğŸ”„ STEP 2: Servo motor starting 360Â° rotation...");
    
    // Start servo rotation
    myServo.write(0);
    delay(100);
  }
  
  // ===== STEP 3: Rotate servo 360 degrees =====
  if (servoRunning) {
    unsigned long servoElapsed = millis() - servoStartTime;
    
    if (servoElapsed < 2000) {
      int angle = map(servoElapsed, 0, 2000, 0, 180);
      myServo.write(angle);
      
      // Show progress
      static unsigned long lastServoUpdate = 0;
      if (millis() - lastServoUpdate > 500) {
        Serial.print("   Servo angle: ");
        Serial.print(angle);
        Serial.println("Â°");
        lastServoUpdate = millis();
      }
    } else {
      // Servo rotation complete
      servoRunning = false;
      myServo.write(0);
      Serial.println("âœ… Servo: 360Â° rotation complete");
      Serial.println();
      
      // STEP 4: Get GPS location and time, then send SMS
      Serial.println("ğŸ“ STEP 3: Getting GPS location and time...");
      Serial.println();
      
      // Try to get GPS location and time
      bool gotGPS = getGPSLocation();
      
      // If GPS failed, use network time as fallback
      if (!gotGPS || timeStr == "" || timeStr == "Time unavailable") {
        Serial.println("âš ï¸ GPS time not available, using network time as fallback...");
        timeStr = getPhilippineTimeFromNetwork();
      }
      
      // Build SMS message
      String sms = "FLOOD ALERT!\n";
      sms += "Harness sensor detected water\n";
      sms += "Inflation: 10s\n";
      sms += "Status: UNSAFE\n";
      sms += "Time: " + timeStr + "\n";
      
      // Add location if GPS was successful
      if (gotGPS && latStr != "" && lngStr != "") {
        sms += "Location: https://maps.google.com/?q=" + latStr + "," + lngStr;
      } else {
        sms += "Location: GPS unavailable";
      }
      
      // Show what we're sending
      Serial.println("\nğŸ“± SMS Content:");
      Serial.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
      Serial.println(sms);
      Serial.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
      
      // Send SMS
      sendSMS(sms);
      
      smsSent = true;
      Serial.println();
      Serial.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
      Serial.println("â•‘   âœ… SEQUENCE COMPLETE!           â•‘");
      Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
      Serial.println();
    }
  }
  
  // ===== RESET WHEN WATER CLEARS =====
  if (triggered && smsSent && waterDetected == LOW) {
    triggered = false;
    pumpRunning = false;
    servoRunning = false;
    smsSent = false;
    
    // Reset location variables
    latStr = "";
    lngStr = "";
    timeStr = "";
    
    Serial.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Serial.println("â•‘   ğŸ’š System Reset                  â•‘");
    Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    Serial.println("Water level normal - Ready for next detection\n");
  }
  
  delay(50);
}