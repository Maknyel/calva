#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <time.h>

// ===== PIN DEFINITIONS =====
#define WATER_SENSOR 27
#define RELAY_PIN    26
#define A7670E_RX    16
#define A7670E_TX    17
#define A7670E_PWR   25

// ===== SERIAL PORT =====
HardwareSerial a7670e(1);

// ===== CONFIGURATION =====
String phoneNumber = "+639070653250";

// ===== LOGIC VARIABLES =====
bool triggered = false;
bool pumpRunning = false;
bool smsSent = false;
unsigned long pumpStartTime = 0;
const unsigned long PUMP_DURATION = 10000;

// ===== LOCATION & TIME VARIABLES =====
String latStr = "";
String lngStr = "";
String timeStr = "";

// ===== HELPER FUNCTION =====
String waitForResponse(int timeout = 2000) {
  String response = "";
  unsigned long start = millis();
  while (millis() - start < (unsigned long)timeout) {
    while (a7670e.available()) {
      char c = a7670e.read();
      response += c;
      Serial.write(c);
    }
  }
  Serial.println();
  return response;
}

// ===== FORMAT GPS UTC (yyyymmddhhmmss.sss) TO PHT =====
String formatGPSTime(String utc) {
  if (utc.length() < 14) return "";

  String year = utc.substring(0, 4);
  String month = utc.substring(4, 6);
  String day = utc.substring(6, 8);
  String hour = utc.substring(8, 10);
  String minute = utc.substring(10, 12);
  String second = utc.substring(12, 14);

  int hr = hour.toInt() + 8;
  int dy = day.toInt();
  int mn = month.toInt();
  int yr = year.toInt();

  // Simple day rollover (doesn't fully handle month/year ends, but ok for display)
  if (hr >= 24) {
    hr -= 24;
    dy++;
  }

  String months[] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
  String monthName = (mn >= 1 && mn <= 12) ? months[mn - 1] : month;

  char buf[50];
  sprintf(buf, "%s %02d, %04d %02d:%s:%s PHT",
          monthName.c_str(), dy, yr, hr, minute.c_str(), second.c_str());

  return String(buf);
}

// ===== GET MODULE TIME (AT+CCLK?) AS PHT =====
// Example response: +CCLK: "24/01/28,09:12:33+32"
// +32 = 8 hours offset (each step = 15 minutes). Philippines is +32.
String getModuleTime() {
  Serial.println("\nüïê Getting module time (AT+CCLK?)...");
  a7670e.println("AT+CCLK?");
  String r = waitForResponse(2000);

  int p = r.indexOf("+CCLK:");
  if (p < 0) return "";

  int q1 = r.indexOf('"', p);
  int q2 = r.indexOf('"', q1 + 1);
  if (q1 < 0 || q2 < 0) return "";

  String t = r.substring(q1 + 1, q2); // yy/MM/dd,hh:mm:ss+tz
  // Format: "yy/MM/dd,hh:mm:ss+tz"
  if (t.length() < 17) return "";

  String yy = t.substring(0, 2);
  String MM = t.substring(3, 5);
  String dd = t.substring(6, 8);
  String hh = t.substring(9, 11);
  String mm = t.substring(12, 14);
  String ss = t.substring(15, 17);

  int year = 2000 + yy.toInt();
  int month = MM.toInt();
  int day = dd.toInt();

  String months[] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
  String monthName = (month >= 1 && month <= 12) ? months[month - 1] : MM;

  char buf[50];
  sprintf(buf, "%s %02d, %04d %02d:%02d:%02d PHT",
          monthName.c_str(), day, year, hh.toInt(), mm.toInt(), ss.toInt());

  Serial.println("‚úÖ Module time: " + String(buf));
  return String(buf);
}

// ===== POWER ON MODULE =====
void powerOnA7670E() {
  Serial.println("üîå Powering on A7670E...");
  pinMode(A7670E_PWR, OUTPUT);
  digitalWrite(A7670E_PWR, HIGH);
  delay(500);
  digitalWrite(A7670E_PWR, LOW);
  delay(1000);
  digitalWrite(A7670E_PWR, HIGH);
  delay(5000);
}

// ===== TRY GPS MODULE (10 seconds max) =====
bool tryGPSModule() {
  Serial.println("\nüõ∞Ô∏è Trying GPS module (10 sec)...");

  a7670e.println("AT+CGNSPWR=1");
  String r = waitForResponse(2000);

  if (r.indexOf("ERROR") >= 0) {
    Serial.println("‚ùå GPS module not available");
    return false;
  }

  for (int i = 0; i < 5; i++) {
    Serial.printf("GPS attempt %d/5...\n", i + 1);

    a7670e.println("AT+CGNSINF");
    String resp = waitForResponse(2000);

    int p = resp.indexOf("+CGNSINF:");
    if (p >= 0) {
      String data = resp.substring(p + 10);
      data.trim();

      // Parse key fields:
      // +CGNSINF: <run>,<fix>,<utc>,<lat>,<lon>,...
      int c1 = data.indexOf(',');
      int c2 = data.indexOf(',', c1 + 1);
      int c3 = data.indexOf(',', c2 + 1);
      int c4 = data.indexOf(',', c3 + 1);
      int c5 = data.indexOf(',', c4 + 1);

      if (c5 > 0) {
        String fix = data.substring(c1 + 1, c2); fix.trim();
        String utc = data.substring(c2 + 1, c3); utc.trim();
        String lat = data.substring(c3 + 1, c4); lat.trim();
        String lon = data.substring(c4 + 1, c5); lon.trim();

        if (fix == "1" && lat != "0.0" && lon != "0.0" && lat.length() > 0) {
          latStr = lat;
          lngStr = lon;

          String gpsTime = formatGPSTime(utc);
          if (gpsTime != "") {
            timeStr = gpsTime;
            Serial.println("‚úÖ GPS TIME: " + timeStr);
          }

          Serial.println("‚úÖ GPS FIX!");
          Serial.println("Lat: " + latStr);
          Serial.println("Lng: " + lngStr);
          return true;
        }
      }
    }

    delay(1000);
  }

  Serial.println("‚ö†Ô∏è No GPS fix");
  return false;
}

// ===== FALLBACK TIME: UPTIME =====
String getUptimeString() {
  unsigned long seconds = millis() / 1000;
  unsigned long h = seconds / 3600;
  unsigned long m = (seconds % 3600) / 60;
  unsigned long s = seconds % 60;

  char buf[40];
  sprintf(buf, "Uptime: %02luh:%02lum:%02lus", h, m, s);
  return String(buf);
}

// ===== SEND SMS (ALWAYS TRY) =====
void sendSMS(String msg) {
  Serial.println("\n‚û°Ô∏è Sending SMS...");

  while (a7670e.available()) a7670e.read();
  delay(300);

  a7670e.println("AT");
  waitForResponse(1000);

  a7670e.println("AT+CMGF=1");
  waitForResponse(1000);

  a7670e.println("AT+CSCS=\"GSM\"");
  waitForResponse(1000);

  while (a7670e.available()) a7670e.read();

  a7670e.print("AT+CMGS=\"");
  a7670e.print(phoneNumber);
  a7670e.println("\"");

  delay(2000);

  bool gotPrompt = false;
  unsigned long start = millis();
  while (millis() - start < 7000) {
    if (a7670e.available()) {
      char c = a7670e.read();
      Serial.write(c);
      if (c == '>') {
        gotPrompt = true;
        Serial.println("\n‚úÖ Prompt");
        break;
      }
    }
  }

  if (!gotPrompt) {
    Serial.println("‚ùå No prompt! (Network/SMS not ready)");
    a7670e.write(27);
    return;
  }

  delay(300);
  a7670e.print(msg);
  delay(300);
  a7670e.write(26);

  Serial.println("üì§ Waiting...");
  String resp = "";
  start = millis();
  while (millis() - start < 30000) {
    while (a7670e.available()) {
      char c = a7670e.read();
      resp += c;
      Serial.write(c);
    }
    if (resp.indexOf("+CMGS:") >= 0) {
      Serial.println("\n‚úÖ SMS SENT!");
      return;
    }
    if (resp.indexOf("ERROR") >= 0) {
      Serial.println("\n‚ùå FAILED!");
      return;
    }
  }
  Serial.println("\n‚ö†Ô∏è Timeout");
}

// ===== SETUP =====
void setup() {
  pinMode(WATER_SENSOR, INPUT);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, HIGH);

  Serial.begin(115200);
  delay(1000);

  Serial.println("\n========================================");
  Serial.println("  FLOOD DETECTION SYSTEM");
  Serial.println("  NO SERVO | NO WIFI");
  Serial.println("  SMS ALWAYS SEND (GPS optional)");
  Serial.println("========================================\n");

  powerOnA7670E();

  Serial.println("üì° Initializing A7670E...");
  a7670e.begin(115200, SERIAL_8N1, A7670E_RX, A7670E_TX);
  delay(2000);

  a7670e.println("AT");
  waitForResponse(2000);

  a7670e.println("ATE0");
  waitForResponse(1000);

  // Optional: ask module to auto-update time from network (depends on network support)
  a7670e.println("AT+CTZU=1");   // auto time zone update
  waitForResponse(1000);
  a7670e.println("AT+CTZR=1");   // enable time zone reporting
  waitForResponse(1000);

  Serial.println("\n‚è≥ Network registration...");
  for (int i = 0; i < 40; i++) {
    a7670e.println("AT+CREG?");
    String r = waitForResponse(1000);
    if (r.indexOf("+CREG: 0,1") >= 0 || r.indexOf("+CREG: 0,5") >= 0) {
      Serial.println("‚úÖ Network OK!");
      break;
    }
    if (i % 5 == 0) Serial.printf("Searching %d/40\n", i);
    delay(1000);
  }

  a7670e.println("AT+CMGF=1");
  waitForResponse(1000);

  // Turn on GNSS (ok even if no antenna/fix)
  a7670e.println("AT+CGNSPWR=1");
  waitForResponse(2000);

  Serial.println("\n========================================");
  Serial.println("‚úÖ READY!");
  Serial.println("========================================");
  Serial.println("Time Priority: GPS ‚Üí Module Time ‚Üí Uptime");
  Serial.println("Location: GPS ‚Üí Unavailable");
  Serial.println("Monitoring for water...\n");
}

// ===== LOOP =====
void loop() {
  int waterDetected = digitalRead(WATER_SENSOR);

  static unsigned long lastPrint = 0;
  if (!triggered && millis() - lastPrint > 10000) {
    Serial.print("üíß ");
    Serial.println(waterDetected == HIGH ? "DETECTED" : "Normal");
    lastPrint = millis();
  }

  if (waterDetected == HIGH && !triggered) {
    Serial.println("\nüö® WATER DETECTED!");
    triggered = true;
    pumpRunning = true;
    pumpStartTime = millis();

    digitalWrite(RELAY_PIN, LOW);
    Serial.println("üîå Pump ON\n");
  }

  if (pumpRunning && millis() - pumpStartTime >= PUMP_DURATION) {
    pumpRunning = false;

    digitalWrite(RELAY_PIN, HIGH);
    Serial.println("üîå Pump OFF\n");

    // ===== LOCATION (OPTIONAL) =====
    bool hasGPS = tryGPSModule(); // sets latStr/lngStr and maybe timeStr

    // ===== TIME (ALWAYS HAVE SOMETHING) =====
    if (timeStr == "") {
      String modTime = getModuleTime();
      if (modTime != "") timeStr = modTime;
    }
    if (timeStr == "") {
      timeStr = getUptimeString();
      Serial.println("‚ö†Ô∏è Using uptime time: " + timeStr);
    }

    // ===== BUILD SMS (ALWAYS SEND) =====
    String sms = "FLOOD ALERT!\n";
    sms += "Harness sensor detected water\n";
    sms += "Status: UNSAFE\n";
    sms += "Time: " + timeStr + "\n";

    if (hasGPS && latStr != "" && lngStr != "") {
      sms += "Location: https://www.google.com/maps?q=" + latStr + "," + lngStr;
    } else {
      sms += "Location: Unavailable";
    }

    Serial.println("üì± SMS:");
    Serial.println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    Serial.println(sms);
    Serial.println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n");

    // ALWAYS send, even without GPS
    sendSMS(sms);

    smsSent = true;
    Serial.println("‚úÖ COMPLETE!\n");
  }

  if (triggered && smsSent && waterDetected == LOW) {
    triggered = false;
    pumpRunning = false;
    smsSent = false;
    latStr = "";
    lngStr = "";
    timeStr = "";

    Serial.println("üíö Reset\n");
  }

  delay(50);
}
