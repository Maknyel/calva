#include <TinyGPS++.h>

// ===== PIN DEFINITIONS =====
#define WATER_SENSOR 27
#define RELAY_PIN    26
#define SIM800_RX    16
#define SIM800_TX    17
#define GPS_RX       18
#define GPS_TX       19

// ===== SERIAL PORTS =====
HardwareSerial sim800(1);
HardwareSerial gpsSerial(2);
TinyGPSPlus gps;

// ===== CONFIGURATION =====
String phoneNumber = "+639070653250";

// ===== LOGIC VARIABLES =====
bool triggered = false;
bool pumpRunning = false;
bool smsSent = false;
unsigned long pumpStartTime = 0;
unsigned long detectionTime = 0;

const unsigned long PUMP_DURATION = 8500;

// ===== STORE LAST VALID GPS DATA =====
double lastLat = 0.0;
double lastLng = 0.0;
bool gpsEverFixed = false;

// ===== SIM800 RESPONSE =====
void waitForResponse(int timeout = 2000) {
  unsigned long start = millis();
  while (millis() - start < timeout) {
    while (sim800.available()) {
      Serial.write(sim800.read());
    }
  }
  Serial.println();
}

// ===== TIME STRING =====
String getCurrentTime() {
  if (gps.time.isValid() && gps.date.isValid()) {
    int hour = gps.time.hour() + 8;
    int day = gps.date.day();
    int month = gps.date.month();
    int year = gps.date.year();

    if (hour >= 24) {
      hour -= 24;
      day++;
    }

    char buf[40];
    sprintf(buf, "%02d/%02d/%04d %02d:%02d:%02d PHT",
            month, day, year, hour,
            gps.time.minute(), gps.time.second());
    return String(buf);
  }

  return "Time unavailable";
}

// ===== GPS LOCATION =====
String getGPSLocation() {
  Serial.println("üìç Getting GPS location...");

  // Try to get fresh GPS data for up to 10 seconds
  unsigned long start = millis();
  while (millis() - start < 10000) {
    while (gpsSerial.available()) {
      gps.encode(gpsSerial.read());
    }

    if (gps.location.isValid() && gps.satellites.value() >= 4) {
      lastLat = gps.location.lat();
      lastLng = gps.location.lng();
      gpsEverFixed = true;

      Serial.print("‚úÖ GPS FIX OK (Satellites: ");
      Serial.print(gps.satellites.value());
      Serial.println(")");
      
      String loc = String(lastLat, 6) + ", " + String(lastLng, 6);
      loc += "\nMaps: https://maps.google.com/?q=" +
             String(lastLat, 6) + "," + String(lastLng, 6);
      return loc;
    }
    delay(100);
  }

  // If no fresh fix, use last known location
  if (gpsEverFixed) {
    Serial.println("‚ö†Ô∏è Using last known GPS location");
    String loc = String(lastLat, 6) + ", " + String(lastLng, 6);
    loc += "\nMaps: https://maps.google.com/?q=" +
           String(lastLat, 6) + "," + String(lastLng, 6);
    loc += "\n(Last known position)";
    return loc;
  }

  Serial.println("‚ùå No GPS data available");
  return "GPS unavailable";
}

// ===== SEND SMS =====
void sendSMS(String msg) {
  Serial.println("üì§ Sending SMS...");

  sim800.println("AT");
  waitForResponse();

  sim800.println("AT+CMGF=1");
  waitForResponse();

  sim800.println("AT+CSCS=\"IRA\"");
  waitForResponse();

  sim800.println("AT+CMGS=\"" + phoneNumber + "\"");
  delay(2000);

  for (uint16_t i = 0; i < msg.length(); i++) {
    sim800.write(msg[i]);
    delay(5);
  }

  sim800.write(26);  // CTRL+Z
  Serial.println("‚è≥ Waiting for SMS confirmation...");

  unsigned long t = millis();
  while (millis() - t < 15000) {
    while (sim800.available()) {
      String r = sim800.readString();
      Serial.print(r);
      if (r.indexOf("+CMGS:") >= 0) {
        Serial.println("‚úÖ SMS SENT");
        return;
      }
    }
  }

  Serial.println("‚ö†Ô∏è SMS status unknown");
}

// ===== SETUP =====
void setup() {
  pinMode(WATER_SENSOR, INPUT);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, HIGH);

  Serial.begin(115200);
  delay(1000);

  gpsSerial.begin(9600, SERIAL_8N1, GPS_RX, GPS_TX);
  sim800.begin(9600, SERIAL_8N1, SIM800_RX, SIM800_TX);

  Serial.println("‚úÖ SYSTEM READY");
  Serial.println("üõ∞Ô∏è GPS warming up... (this may take 30-60 seconds)");
}

// ===== LOOP =====
void loop() {
  // ===== CONTINUOUSLY UPDATE GPS =====
  while (gpsSerial.available()) {
    gps.encode(gpsSerial.read());
    
    // Store valid location data
    if (gps.location.isValid()) {
      lastLat = gps.location.lat();
      lastLng = gps.location.lng();
      if (!gpsEverFixed) {
        gpsEverFixed = true;
        Serial.print("üõ∞Ô∏è GPS FIRST FIX! Satellites: ");
        Serial.println(gps.satellites.value());
      }
    }
  }

  int waterDetected = digitalRead(WATER_SENSOR);

  // ===== TRIGGER =====
  if (waterDetected == HIGH && !triggered) {
    triggered = true;
    pumpRunning = true;
    pumpStartTime = millis();
    detectionTime = millis();

    digitalWrite(RELAY_PIN, LOW);
    Serial.println("üö® WATER DETECTED ‚Äî Pump ON");
  }

  // ===== STOP PUMP =====
  if (pumpRunning && millis() - pumpStartTime >= PUMP_DURATION) {
    pumpRunning = false;
    digitalWrite(RELAY_PIN, HIGH);

    Serial.println("üîå Pump OFF");

    // ===== GPS + SMS =====
    String location = getGPSLocation();
    String timeStr = getCurrentTime();

    String sms =
      "FLOOD ALERT!\n"
      "Status: UNSAFE\n"
      "Time: " + timeStr + "\n"
      "Location:\n" + location;

    sendSMS(sms);
    smsSent = true;
  }

  // ===== RESET =====
  if (triggered && smsSent && waterDetected == LOW) {
    triggered = false;
    smsSent = false;

    Serial.println("üíö System reset");
  }

  delay(50);
}