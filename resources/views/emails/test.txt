#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>

// ===== PIN DEFINITIONS =====
#define WATER_SENSOR 27
#define RELAY_PIN    26
#define A7670E_RX    16
#define A7670E_TX    17
#define A7670E_PWR   25

// ===== WIFI CONFIGURATION =====
const char* ssid = "TestingWifi";
const char* password = "Abc1234567";
const char* apiURL = "https://harness.dl-hosting.net/api_location.php";
bool systemHalted = false;

// ===== SERIAL PORT =====
HardwareSerial a7670e(1);

// ===== CONFIGURATION =====
String phoneNumber = "+639070653250";

// ===== LOGIC VARIABLES =====
bool triggered = false;
bool pumpRunning = false;
bool smsSent = false;
unsigned long pumpStartTime = 0;

const unsigned long PUMP_DURATION = 8500;

// ===== STORE API DATA =====
String apiTime = "";
double apiLat = 0.0;
double apiLng = 0.0;
bool apiDataAvailable = false;

// ===== GPS DATA FROM A7670E =====
String gpsLat = "";
String gpsLng = "";
String gpsTime = "";

// ===== MONTH NAMES =====
const char* monthNames[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                             "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
String formatAPITime(String rawTime);

// ===== HELPER: truncate to 4 decimal places =====
double truncate4(double val) {
  if (val >= 0)
    return (int)(val * 10000) / 10000.0;
  else
    return -( (int)(-val * 10000) / 10000.0 );
}

// ===== READ A7670E RESPONSE =====
String readA7670E(int timeout = 2000) {
  String result = "";
  unsigned long start = millis();
  while (millis() - start < timeout) {
    while (a7670e.available()) {
      char c = a7670e.read();
      result += c;
      Serial.write(c);
    }
  }
  Serial.println();
  return result;
}

// ===== WIFI CONNECTION =====
bool connectWiFi() {
  Serial.println("Connecting to WiFi...");
  WiFi.begin(ssid, password);
  
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < 10000) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("WiFi Connected!");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
    return true;
  } else {
    Serial.println("WiFi Connection Failed");
    return false;
  }
}

// ===== GET DATA FROM API =====
bool getDataFromAPI() {
  Serial.println("Getting REAL-TIME data from API...");
  
  if (WiFi.status() != WL_CONNECTED) {
    if (!connectWiFi()) return false;
  }
  
  HTTPClient http;
  http.begin(apiURL);
  
  int httpCode = http.GET();
  
  if (httpCode == 200) {
    String payload = http.getString();
    Serial.println("API Response: " + payload);
    
    StaticJsonDocument<200> doc;
    DeserializationError error = deserializeJson(doc, payload);
    
    if (!error) {
      apiLat = doc["latitude"];
      apiLng = doc["longhitude"];
      String rawTime = doc["time"].as<String>();
      
      // Update contact number from API if provided
      if (doc.containsKey("current_number")) {
        String apiNumber = doc["current_number"].as<String>();
        if (apiNumber.length() > 0 && apiNumber != phoneNumber) {
          Serial.println("Updating phone number: " + phoneNumber + " -> " + apiNumber);
          phoneNumber = apiNumber;
        }
      }
      
      apiTime = formatAPITime(rawTime);
      apiDataAvailable = true;
      
      Serial.print("API Data - Lat: ");
      Serial.print(apiLat, 6);
      Serial.print(" | Lng: ");
      Serial.print(apiLng, 6);
      Serial.print(" | Time: ");
      Serial.println(apiTime);
      
      http.end();
      return true;
    } else {
      Serial.println("JSON Parse Error");
    }
  } else {
    Serial.print("HTTP Error: ");
    Serial.println(httpCode);
  }
  
  http.end();
  return false;
}

// ===== FORMAT API TIME =====
String formatAPITime(String rawTime) {
  int year = rawTime.substring(0, 4).toInt();
  int month = rawTime.substring(5, 7).toInt();
  int day = rawTime.substring(8, 10).toInt();
  String time = rawTime.substring(11);
  
  String formatted = String(monthNames[month - 1]) + " " + 
                     String(day) + ", " + 
                     String(year) + " " + 
                     time + " PHT";
  return formatted;
}

// ===== FORMAT GPS UTC TO PHT =====
String formatGPSTime(String utc) {
  if (utc.length() < 14) return "";

  int year  = utc.substring(0, 4).toInt();
  int month = utc.substring(4, 6).toInt();
  int day   = utc.substring(6, 8).toInt();
  int hour  = utc.substring(8, 10).toInt() + 8;
  int min   = utc.substring(10, 12).toInt();
  int sec   = utc.substring(12, 14).toInt();

  if (hour >= 24) {
    hour -= 24;
    day++;
  }

  char buf[50];
  sprintf(buf, "%s %02d, %04d %02d:%02d:%02d PHT",
          monthNames[month - 1], day, year, hour, min, sec);
  return String(buf);
}

// ===== TRY GPS FROM A7670E =====
bool tryA7670EGPS() {
  Serial.println("\nüõ∞Ô∏è Trying A7670E GPS...");

  a7670e.println("AT+CGNSPWR=1");
  String r = readA7670E(2000);

  if (r.indexOf("ERROR") >= 0) {
    Serial.println("‚ùå GPS not available on A7670E");
    return false;
  }

  for (int i = 0; i < 5; i++) {
    Serial.print("GPS attempt ");
    Serial.print(i + 1);
    Serial.println(" of 5...");

    a7670e.println("AT+CGNSINF");
    String resp = readA7670E(2000);

    int p = resp.indexOf("+CGNSINF:");
    if (p >= 0) {
      String data = resp.substring(p + 10);
      data.trim();

      int c1 = data.indexOf(',');
      int c2 = data.indexOf(',', c1 + 1);
      int c3 = data.indexOf(',', c2 + 1);
      int c4 = data.indexOf(',', c3 + 1);
      int c5 = data.indexOf(',', c4 + 1);

      if (c5 > 0) {
        String fix = data.substring(c1 + 1, c2); fix.trim();
        String utc = data.substring(c2 + 1, c3); utc.trim();
        String lat = data.substring(c3 + 1, c4); lat.trim();
        String lon = data.substring(c4 + 1, c5); lon.trim();

        if (fix == "1" && lat.length() > 0 && lat != "0.0" && lon != "0.0") {
          gpsLat = lat;
          gpsLng = lon;

          String formatted = formatGPSTime(utc);
          if (formatted != "") {
            gpsTime = formatted;
            Serial.println("‚úÖ GPS Time: " + gpsTime);
          }

          Serial.println("‚úÖ GPS FIX! Lat: " + gpsLat + " Lng: " + gpsLng);
          return true;
        }
      }
    }
    delay(2000);
  }

  Serial.println("‚ö†Ô∏è No GPS fix from A7670E");
  return false;
}

// ===== GET LOCATION =====
// Priority: A7670E GPS ‚Üí API
String getLocation() {
  if (tryA7670EGPS()) {
    return gpsLat + "," + gpsLng;
  }

  Serial.println("Trying API for location...");
  for (int attempt = 1; attempt <= 3; attempt++) {
    Serial.print("API attempt ");
    Serial.print(attempt);
    Serial.println(" of 3...");

    if (getDataFromAPI() && (apiLat != 0.0 || apiLng != 0.0)) {
      apiLat = truncate4(apiLat);
      apiLng = truncate4(apiLng);
      Serial.println("Got location from API");
      return String(apiLat, 6) + "," + String(apiLng, 6);
    }
    delay(3000);
  }

  Serial.println("CRITICAL: No location source available");
  return "";
}

// ===== GET TIME =====
// Priority: GPS time ‚Üí API time
String getTime() {
  if (gpsTime != "") return gpsTime;

  Serial.println("GPS time unavailable, using API time...");
  if (apiDataAvailable && apiTime.length() > 0) return apiTime;

  Serial.println("Trying fresh API call for time...");
  if (getDataFromAPI() && apiTime.length() > 0) return apiTime;

  return "Unavailable";
}

// ===== POWER ON MODULE =====
void powerOnA7670E() {
  Serial.println("üîå Powering on A7670E...");
  pinMode(A7670E_PWR, OUTPUT);
  digitalWrite(A7670E_PWR, HIGH);
  delay(500);
  digitalWrite(A7670E_PWR, LOW);
  delay(1000);
  digitalWrite(A7670E_PWR, HIGH);
  delay(5000);
}

// ===== SEND SMS =====
void sendSMS(String msg) {
  Serial.println("\n‚û°Ô∏è Sending SMS...");

  Serial.println("Disconnecting WiFi...");
  WiFi.disconnect(true);
  delay(1000);

  while (a7670e.available()) a7670e.read();
  delay(500);

  Serial.println("Syncing module...");
  a7670e.println("AT");
  delay(1000);
  String res = readA7670E(1000);
  Serial.println("AT response: " + res);

  a7670e.println("ATE0");
  delay(1000);
  readA7670E(1000);

  a7670e.println("AT+CMGF=1");
  delay(1000);
  res = readA7670E(1000);
  Serial.println("CMGF response: " + res);

  a7670e.println("AT+CSCS=\"GSM\"");
  delay(1000);
  readA7670E(1000);

  a7670e.println("AT+CSQ");
  delay(1000);
  res = readA7670E(1000);
  Serial.println("Signal: " + res);

  a7670e.println("AT+CREG?");
  delay(1000);
  res = readA7670E(1000);
  Serial.println("Network: " + res);

  a7670e.println("AT+CNETMODE=0");
  delay(1000);
  readA7670E(1000);

  a7670e.println("AT+CEREG?");
  delay(1000);
  res = readA7670E(1000);
  Serial.println("4G Network: " + res);

  Serial.println("Sending AT+CMGS...");
  a7670e.println("AT+CMGS=\"" + phoneNumber + "\"");
  delay(3000);

  bool promptReceived = false;
  unsigned long promptWait = millis();
  while (millis() - promptWait < 5000) {
    if (a7670e.available()) {
      char c = a7670e.read();
      Serial.write(c);
      if (c == '>') {
        promptReceived = true;
        break;
      }
    }
  }

  if (!promptReceived) {
    Serial.println("\n‚ùå No prompt received! Aborting SMS.");
    a7670e.write(27);
    return;
  }

  Serial.println("\n‚úÖ Prompt received, sending message...");
  delay(500);

  a7670e.print(msg);
  Serial.println(msg);

  delay(2000);

  while (a7670e.available()) a7670e.read();
  delay(500);

  a7670e.write(26);
  Serial.println("\nüì§ Ctrl+Z sent. Waiting for +CMGS:...");

  String response = "";
  unsigned long sendStart = millis();
  while (millis() - sendStart < 30000) {
    while (a7670e.available()) {
      char c = a7670e.read();
      response += c;
      Serial.write(c);
    }

    if (response.indexOf("+CMGS:") >= 0) {
      Serial.println("\n‚úÖ SMS SENT SUCCESSFULLY!");
      return;
    }
    if (response.indexOf("ERROR") >= 0) {
      Serial.println("\n‚ùå SMS FAILED! Response: " + response);
      return;
    }
    delay(100);
  }

  Serial.println("\n‚ö†Ô∏è SMS status unknown (timeout). Full response was: " + response);
}

// ===== SETUP =====
void setup() {
  pinMode(WATER_SENSOR, INPUT);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, HIGH);

  Serial.begin(115200);
  delay(1000);

  powerOnA7670E();

  // A7670E baud rate auto-detect
  int baudRates[] = {115200, 9600, 19200, 38400, 57600};
  bool found = false;

  for (int i = 0; i < 5; i++) {
    Serial.print("Trying baud rate: ");
    Serial.println(baudRates[i]);

    a7670e.begin(baudRates[i], SERIAL_8N1, A7670E_RX, A7670E_TX);
    delay(1000);

    while (a7670e.available()) a7670e.read();

    a7670e.println("AT");
    delay(2000);

    String res = "";
    while (a7670e.available()) {
      res += (char)a7670e.read();
    }

    Serial.print("Response: ");
    Serial.println(res);

    if (res.indexOf("OK") >= 0) {
      Serial.print("A7670E found at baud rate: ");
      Serial.println(baudRates[i]);
      found = true;
      break;
    }

    a7670e.end();
    delay(500);
  }

  if (!found) {
    Serial.println("A7670E not responding at any baud rate!");
  }

  delay(1000);

  // Configure module
  a7670e.println("ATE0");
  readA7670E(1000);

  a7670e.println("AT+CMGF=1");
  readA7670E(1000);

  a7670e.println("AT+CSCS=\"GSM\"");
  readA7670E(1000);

  // Wait for network
  Serial.println("Waiting for network...");
  for (int i = 0; i < 40; i++) {
    a7670e.println("AT+CREG?");
    String r = readA7670E(1000);
    if (r.indexOf("+CREG: 0,1") >= 0 || r.indexOf("+CREG: 0,5") >= 0) {
      Serial.println("‚úÖ Network OK!");
      break;
    }
    if (i % 5 == 0) {
      Serial.print("Searching ");
      Serial.print(i);
      Serial.println("/40");
    }
    delay(1000);
  }

  // Enable GNSS
  a7670e.println("AT+CGNSPWR=1");
  readA7670E(2000);
  Serial.println("GNSS enabled");

  delay(3000);

  Serial.println("SYSTEM READY");
  Serial.println("GPS: A7670E built-in GNSS");
  Serial.println("Fallback: WiFi API");
  Serial.println("Monitoring for water...");
}

// ===== LOOP =====
void loop() {
  if (systemHalted) return;

  int waterDetected = digitalRead(WATER_SENSOR);

  // ===== TRIGGER =====
  if (waterDetected == HIGH && !triggered) {
    triggered = true;
    pumpRunning = true;
    pumpStartTime = millis();

    digitalWrite(RELAY_PIN, LOW);
    Serial.println("WATER DETECTED - Pump ON");
  }

  // ===== STOP PUMP =====
  if (pumpRunning && millis() - pumpStartTime >= PUMP_DURATION) {
    pumpRunning = false;
    digitalWrite(RELAY_PIN, HIGH);
    Serial.println("Pump OFF");

    // Reset
    gpsLat = "";
    gpsLng = "";
    gpsTime = "";
    apiDataAvailable = false;
    apiTime = "";
    apiLat = 0.0;
    apiLng = 0.0;

    // Location FIRST (also caches apiTime if GPS fails)
    String location = getLocation();
    // Time SECOND
    String timeStr = getTime();

    // Build single SMS
    String sms = "Harness sensor detected water\r\n";
    sms += "Status: UNSAFE\r\n";
    sms += "Time: " + timeStr + "\r\n";

    if (location != "") {
      sms += "Location: https://maps.google.com/maps/?q=" + location;
    } else {
      sms += "Location: Unavailable";
    }

    Serial.println("\nüì± SMS Content:");
    Serial.println("---------------------------------");
    Serial.println(sms);
    Serial.println("---------------------------------");

    sendSMS(sms);
    systemHalted = true;
    smsSent = true;
  }

  // ===== RESET =====
  if (triggered && smsSent && waterDetected == LOW) {
    triggered = false;
    smsSent = false;
    systemHalted = false;

    Serial.println("System reset");
  }

  delay(50);
}