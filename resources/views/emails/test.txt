#include <TinyGPS++.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>

// ===== PIN DEFINITIONS =====
#define WATER_SENSOR 27
#define RELAY_PIN    26
#define SIM800_RX    16
#define SIM800_TX    17
#define GPS_RX       18
#define GPS_TX       19

// ===== WIFI CONFIGURATION =====
const char* ssid = "TestingWifi";
const char* password = "Abc1234567";
const char* apiURL = "https://harness.dl-hosting.net/api_location.php";
bool systemHalted = false;


// ===== SERIAL PORTS =====
HardwareSerial sim800(1);
HardwareSerial gpsSerial(2);
TinyGPSPlus gps;

// ===== CONFIGURATION =====
String phoneNumber = "+639070653250";

// ===== LOGIC VARIABLES =====
bool triggered = false;
bool pumpRunning = false;
bool smsSent = false;
unsigned long pumpStartTime = 0;
unsigned long detectionTime = 0;

const unsigned long PUMP_DURATION = 8500;

// ===== STORE LAST VALID GPS DATA =====
double lastLat = 0.0;
double lastLng = 0.0;
bool gpsEverFixed = false;

// ===== STORE API DATA =====
String apiTime = "";
double apiLat = 0.0;
double apiLng = 0.0;
bool apiDataAvailable = false;

// ===== GPS DIAGNOSTICS =====
unsigned long lastGPSCheck = 0;
unsigned long gpsCharCount = 0;

// ===== MONTH NAMES =====
const char* monthNames[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                             "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
String formatAPITime(String rawTime);
// ===== HELPER: days in a given month (handles leap year) =====
int daysInMonth(int month, int year) {
  const int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  if (month == 2) {
    bool leap = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    return leap ? 29 : 28;
  }
  return days[month - 1];
}

// ===== HELPER: truncate to 4 decimal places =====
double truncate4(double val) {
  if (val >= 0)
    return (int)(val * 10000) / 10000.0;
  else
    return -( (int)(-val * 10000) / 10000.0 );
}

// ===== WIFI CONNECTION =====
bool connectWiFi() {
  Serial.println("Connecting to WiFi...");
  WiFi.begin(ssid, password);
  
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < 10000) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("WiFi Connected!");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
    return true;
  } else {
    Serial.println("WiFi Connection Failed");
    return false;
  }
}

// ===== GET DATA FROM API =====
bool getDataFromAPI() {
  Serial.println("Getting REAL-TIME data from API...");
  
  if (WiFi.status() != WL_CONNECTED) {
    if (!connectWiFi()) {
      return false;
    }
  }
  
  HTTPClient http;
  http.begin(apiURL);
  
  int httpCode = http.GET();
  
  if (httpCode == 200) {
    String payload = http.getString();
    Serial.println("API Response: " + payload);
    
    StaticJsonDocument<200> doc;
    DeserializationError error = deserializeJson(doc, payload);
    
    if (!error) {
      apiLat = doc["latitude"];
      apiLng = doc["longhitude"];
      String rawTime = doc["time"].as<String>();
      
      apiTime = formatAPITime(rawTime);
      apiDataAvailable = true;
      
      Serial.print("API Data - Lat: ");
      Serial.print(apiLat, 6);
      Serial.print(" | Lng: ");
      Serial.print(apiLng, 6);
      Serial.print(" | Time: ");
      Serial.println(apiTime);
      
      http.end();
      return true;
    } else {
      Serial.println("JSON Parse Error");
    }
  } else {
    Serial.print("HTTP Error: ");
    Serial.println(httpCode);
  }
  
  http.end();
  return false;
}

// ===== FORMAT API TIME =====
String formatAPITime(String rawTime) {
  int year = rawTime.substring(0, 4).toInt();
  int month = rawTime.substring(5, 7).toInt();
  int day = rawTime.substring(8, 10).toInt();
  String time = rawTime.substring(11);
  
  String formatted = String(monthNames[month - 1]) + " " + 
                     String(day) + ", " + 
                     String(year) + " " + 
                     time + " PHT";
  
  return formatted;
}

// ===== READ SIM800 RESPONSE INTO STRING =====
String readSIM800(int timeout = 2000) {
  String result = "";
  unsigned long start = millis();
  while (millis() - start < timeout) {
    while (sim800.available()) {
      char c = sim800.read();
      result += c;
      Serial.write(c);
    }
  }
  Serial.println();
  return result;
}

// ===== TIME STRING =====
String getCurrentTime() {
  if (gps.time.isValid() && gps.date.isValid() && gps.location.isValid() && gps.satellites.value() >= 4) {
    int hour = gps.time.hour() + 8;
    int day = gps.date.day();
    int month = gps.date.month();
    int year = gps.date.year();

    if (hour >= 24) {
      hour -= 24;
      day++;
      if (day > daysInMonth(month, year)) {
        day = 1;
        month++;
        if (month > 12) {
          month = 1;
          year++;
        }
      }
    }

    char buf[50];
    sprintf(buf, "%s %d, %04d %02d:%02d:%02d PHT",
            monthNames[month - 1], day, year, hour,
            gps.time.minute(), gps.time.second());
    return String(buf);
  }
  
  Serial.println("GPS time unavailable, using cached API time...");
  if (apiDataAvailable && apiTime.length() > 0) {
    return apiTime;
  }

  Serial.println("No cached API time, making fresh API call...");
  if (getDataFromAPI() && apiTime.length() > 0) {
    return apiTime;
  }

  return "Time unavailable";
}

// ===== GPS LOCATION =====
String getGPSLocation() {
  Serial.println("Getting GPS location...");

  unsigned long start = millis();
  int charsProcessed = 0;
  
  while (millis() - start < 10000) {
    while (gpsSerial.available()) {
      char c = gpsSerial.read();
      gps.encode(c);
      charsProcessed++;
    }

    if (gps.location.isValid() && gps.satellites.value() >= 4) {
      lastLat = truncate4(gps.location.lat());
      lastLng = truncate4(gps.location.lng());
      gpsEverFixed = true;

      Serial.print("GPS FIX OK (Satellites: ");
      Serial.print(gps.satellites.value());
      Serial.println(")");
      
      String loc = String(lastLat, 6) + "," + String(lastLng, 6);
      return loc;
    }
    delay(100);
  }

  Serial.print("GPS chars received during check: ");
  Serial.println(charsProcessed);

  Serial.println("No GPS data available - getting REAL-TIME location from API");
  
  for (int attempt = 1; attempt <= 3; attempt++) {
    Serial.print("API location attempt ");
    Serial.print(attempt);
    Serial.println(" of 3...");

    if (getDataFromAPI() && (apiLat != 0.0 || apiLng != 0.0)) {
      apiLat = truncate4(apiLat);
      apiLng = truncate4(apiLng);
      String loc = String(apiLat, 6) + "," + String(apiLng, 6);
      Serial.println("Got location from API");
      return loc;
    }
    delay(3000);
  }

  if (gpsEverFixed) {
    Serial.println("Using last known GPS coordinates as fallback");
    String loc = String(lastLat, 6) + "," + String(lastLng, 6);
    return loc;
  }

  Serial.println("CRITICAL: No location source available");
  return "0.0000,0.0000";
}

// ===== SEND SMS =====
void sendSMS(String msg) {
  Serial.println("\n‚û°Ô∏è Sending SMS...");

  // Kill WiFi completely before using SIM800L
  Serial.println("Disconnecting WiFi...");
  WiFi.disconnect(true);
  delay(1000);

  // Flush any garbage in the buffer
  while (sim800.available()) {
    sim800.read();
  }
  delay(500);

  // Send AT to wake/sync the module
  Serial.println("Syncing module...");
  sim800.println("AT");
  delay(1000);
  String res = readSIM800(1000);
  Serial.println("AT response: " + res);

  // Turn off echo ‚Äî this is critical so we don't confuse echo with response
  sim800.println("ATE0");
  delay(1000);
  readSIM800(1000);

  // Set text mode
  sim800.println("AT+CMGF=1");
  delay(1000);
  res = readSIM800(1000);
  Serial.println("CMGF response: " + res);

  // Set charset
  sim800.println("AT+CSCS=\"GSM\"");
  delay(1000);
  readSIM800(1000);

  // Check signal
  sim800.println("AT+CSQ");
  delay(1000);
  res = readSIM800(1000);
  Serial.println("Signal: " + res);

  // Check registration
  sim800.println("AT+CREG?");
  delay(1000);
  res = readSIM800(1000);
  Serial.println("Network: " + res);

  // Start SMS
  Serial.println("Sending AT+CMGS...");
  sim800.println("AT+CMGS=\"" + phoneNumber + "\"");
  delay(3000);

  // Wait for '>' prompt
  bool promptReceived = false;
  unsigned long promptWait = millis();
  while (millis() - promptWait < 5000) {
    if (sim800.available()) {
      char c = sim800.read();
      Serial.write(c);
      if (c == '>') {
        promptReceived = true;
        break;
      }
    }
  }

  if (!promptReceived) {
    Serial.println("\n‚ùå No prompt received! Aborting SMS.");
    sim800.write(27);
    return;
  }

  Serial.println("\n‚úÖ Prompt received, sending message...");
  delay(500);

  // Write message body
  for (unsigned int i = 0; i < msg.length(); i++) {
    sim800.write(msg[i]);
    delay(10);
  }

  delay(1000);

  // Send Ctrl+Z
  sim800.write(26);
  Serial.println("\nüì§ Ctrl+Z sent. Waiting for +CMGS:...");

  // Wait for +CMGS: or ERROR ‚Äî with echo off, response should be clean
  String response = "";
  unsigned long sendStart = millis();
  while (millis() - sendStart < 30000) {
    while (sim800.available()) {
      char c = sim800.read();
      response += c;
      Serial.write(c);
    }

    if (response.indexOf("+CMGS:") >= 0) {
      Serial.println("\n‚úÖ SMS SENT SUCCESSFULLY!");
      return;
    }
    if (response.indexOf("ERROR") >= 0) {
      Serial.println("\n‚ùå SMS FAILED! Response: " + response);
      return;
    }
    delay(100);
  }

  Serial.println("\n‚ö†Ô∏è SMS status unknown (timeout). Full response was: " + response);
}

// ===== SETUP =====
void setup() {
  pinMode(WATER_SENSOR, INPUT);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, HIGH);

  Serial.begin(115200);
  delay(1000);
  
  gpsSerial.begin(9600, SERIAL_8N1, GPS_RX, GPS_TX);
  sim800.begin(9600, SERIAL_8N1, SIM800_RX, SIM800_TX);

  Serial.println("SYSTEM READY");
  Serial.println("GPS warming up... (this may take 30-60 seconds)");
  Serial.println("Monitoring GPS data stream...");
  Serial.println("WiFi will connect when GPS unavailable for real-time data");
}

// ===== LOOP =====
void loop() {
//  if (systemHalted) return;

  // ===== CONTINUOUSLY UPDATE GPS =====
  while (gpsSerial.available()) {
    char c = gpsSerial.read();
    gps.encode(c);
    gpsCharCount++;
    
    if (gps.location.isValid()) {
      lastLat = truncate4(gps.location.lat());
      lastLng = truncate4(gps.location.lng());
      if (!gpsEverFixed) {
        gpsEverFixed = true;
        Serial.print("GPS FIRST FIX! Satellites: ");
        Serial.print(gps.satellites.value());
        Serial.print(" | Lat: ");
        Serial.print(lastLat, 6);
        Serial.print(" | Lng: ");
        Serial.println(lastLng, 6);
      }
    }
  }

  // ===== GPS DIAGNOSTIC (every 10 seconds) =====
  if (millis() - lastGPSCheck > 10000) {
    lastGPSCheck = millis();
    
    Serial.print("GPS Status - Chars received: ");
    Serial.print(gpsCharCount);
    Serial.print(" | Satellites: ");
    Serial.print(gps.satellites.value());
    Serial.print(" | Fix: ");
    Serial.print(gps.location.isValid() ? "YES" : "NO");
    Serial.print(" | Sentences: ");
    Serial.print(gps.sentencesWithFix());
    Serial.print("/");
    Serial.println(gps.passedChecksum());
    
    gpsCharCount = 0;
  }

  int waterDetected = digitalRead(WATER_SENSOR);

  // ===== TRIGGER =====
  if (waterDetected == HIGH && !triggered) {
    triggered = true;
    pumpRunning = true;
    pumpStartTime = millis();
    detectionTime = millis();

    digitalWrite(RELAY_PIN, LOW);
    Serial.println("WATER DETECTED - Pump ON");
  }

  // ===== STOP PUMP =====
  if (pumpRunning && millis() - pumpStartTime >= PUMP_DURATION) {
    pumpRunning = false;
    digitalWrite(RELAY_PIN, HIGH);

    Serial.println("Pump OFF");

    // Reset API data flags to force fresh API call
    apiDataAvailable = false;
    apiTime = "";
    apiLat = 0.0;
    apiLng = 0.0;

    // Location FIRST ‚Äî this triggers the API call and caches apiTime
    String location = getGPSLocation();
    // Time SECOND ‚Äî uses cached apiTime if GPS time unavailable
    String timeStr = getCurrentTime();

    // Location is now just "14.4152,120.9854" ‚Äî no URL characters
    String sms =
      "Harness sensor detected water\n"
      "Status: UNSAFE\n"
      "Time: " + timeStr + "\n"
      "Location: " + location;

    Serial.println("\nüì± SMS Content:");
    Serial.println("---------------------------------");
    Serial.println(sms);
    Serial.println("---------------------------------");

    sendSMS(sms);
    systemHalted = true;

    smsSent = true;
  }

  // ===== RESET =====
  if (triggered && smsSent && waterDetected == LOW) {
    triggered = false;
    smsSent = false;

    Serial.println("System reset");
  }

  delay(50);
}