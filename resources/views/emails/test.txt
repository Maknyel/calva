#include <ESP32Servo.h>

// ===== PIN DEFINITIONS =====
#define WATER_SENSOR 27
#define RELAY_PIN    26
#define SERVO_PIN    14
#define A7670E_RX    16
#define A7670E_TX    17
#define A7670E_PWR   25

// ===== SERIAL PORT =====
HardwareSerial a7670e(1);
Servo myServo;

// ===== CONFIGURATION =====
String phoneNumber = "+639070653250";

// ===== MANUAL TIME SETUP (UPDATE THESE WHEN UPLOADING!) =====
int startYear = 2025;
int startMonth = 1;    // 1-12
int startDay = 26;     // 1-31
int startHour = 15;    // 0-23 (24h format)
int startMinute = 30;  // 0-59
unsigned long bootTime = 0;

// ===== LOGIC VARIABLES =====
bool triggered = false;
bool pumpRunning = false;
bool servoRunning = false;
bool smsSent = false;
unsigned long pumpStartTime = 0;
unsigned long servoStartTime = 0;
const unsigned long PUMP_DURATION = 10000;

// ===== GPS VARIABLES =====
String latStr = "";
String lngStr = "";
String timeStr = "";

// ===== HELPER FUNCTION =====
String waitForResponse(int timeout = 2000) {
  String response = "";
  unsigned long start = millis();
  while (millis() - start < timeout) {
    while (a7670e.available()) {
      char c = a7670e.read();
      response += c;
      Serial.write(c);
    }
  }
  Serial.println();
  return response;
}

// ===== GET TIME FROM SYSTEM UPTIME =====
String getSystemTime() {
  unsigned long elapsed = (millis() - bootTime) / 1000;
  
  int sec = (startMinute * 60 + elapsed) % 60;
  int totalMin = startMinute + (elapsed / 60);
  int min = totalMin % 60;
  int totalHr = startHour + (totalMin / 60);
  int hr = totalHr % 24;
  int day = startDay + (totalHr / 24);
  
  String months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
  
  char buf[40];
  sprintf(buf, "%s %02d, %d %02d:%02d:%02d PHT", 
          months[startMonth-1].c_str(), day, startYear, hr, min, sec);
  return String(buf);
}

// ===== GET NETWORK TIME =====
String getNetworkTime() {
  Serial.println("‚è∞ Trying network time...");
  a7670e.println("AT+CCLK?");
  String resp = waitForResponse(2000);
  
  int idx = resp.indexOf("+CCLK: \"");
  if (idx < 0) return "";
  
  String dt = resp.substring(idx + 8, idx + 25); // "25/01/26,15:30:45"
  if (dt.length() < 17) return "";
  
  String yy = dt.substring(0, 2);
  String mm = dt.substring(3, 5);
  String dd = dt.substring(6, 8);
  String time = dt.substring(9, 17);
  
  int year = 2000 + yy.toInt();
  if (year < 2024 || year > 2030) return "";
  
  String months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
  int m = mm.toInt() - 1;
  if (m < 0 || m > 11) return "";
  
  return months[m] + " " + dd + ", " + String(year) + " " + time + " PHT";
}

// ===== QUICK GPS CHECK (5 ATTEMPTS ONLY) =====
bool getGPSQuick() {
  Serial.println("üõ∞Ô∏è Quick GPS check (outdoors only, 10 sec max)...");
  
  a7670e.println("AT+CGNSPWR=1");
  waitForResponse(1000);
  
  for (int i = 0; i < 5; i++) {
    Serial.printf("GPS attempt %d/5...\n", i + 1);
    
    a7670e.println("AT+CGNSINF");
    String resp = waitForResponse(2000);
    
    int p = resp.indexOf("+CGNSINF:");
    if (p < 0) { delay(1000); continue; }
    
    String data = resp.substring(p + 10);
    
    // Parse: runStatus,fixStatus,UTC,lat,lon,...
    int c1 = data.indexOf(',');
    int c2 = data.indexOf(',', c1 + 1);
    int c3 = data.indexOf(',', c2 + 1);
    int c4 = data.indexOf(',', c3 + 1);
    int c5 = data.indexOf(',', c4 + 1);
    
    if (c5 < 0) continue;
    
    String fix = data.substring(c1 + 1, c2);
    String lat = data.substring(c3 + 1, c4);
    String lon = data.substring(c4 + 1, c5);
    
    fix.trim();
    lat.trim();
    lon.trim();
    
    if (fix == "1" && lat != "0.0" && lon != "0.0" && lat.length() > 0) {
      latStr = lat;
      lngStr = lon;
      Serial.println("‚úÖ GPS FIX! Lat: " + lat + ", Lon: " + lon);
      return true;
    }
    
    delay(1000);
  }
  
  Serial.println("‚ö†Ô∏è No GPS fix (needs clear sky, outdoors)");
  return false;
}

// ===== POWER ON MODULE =====
void powerOnA7670E() {
  Serial.println("üîå Powering on A7670E...");
  pinMode(A7670E_PWR, OUTPUT);
  digitalWrite(A7670E_PWR, HIGH);
  delay(500);
  digitalWrite(A7670E_PWR, LOW);
  delay(1000);
  digitalWrite(A7670E_PWR, HIGH);
  delay(5000);
}

// ===== SEND SMS =====
void sendSMS(String msg) {
  Serial.println("\n‚û°Ô∏è Sending SMS...");
  
  while (a7670e.available()) a7670e.read();
  delay(500);
  
  a7670e.println("AT");
  waitForResponse(1000);
  
  a7670e.println("AT+CMGF=1");
  waitForResponse(1000);
  
  a7670e.println("AT+CSCS=\"GSM\"");
  waitForResponse(1000);
  
  while (a7670e.available()) a7670e.read();
  
  a7670e.print("AT+CMGS=\"");
  a7670e.print(phoneNumber);
  a7670e.println("\"");
  
  delay(2000);
  
  bool gotPrompt = false;
  unsigned long start = millis();
  while (millis() - start < 5000) {
    if (a7670e.available()) {
      char c = a7670e.read();
      Serial.write(c);
      if (c == '>') {
        gotPrompt = true;
        Serial.println("\n‚úÖ Got prompt");
        break;
      }
    }
  }
  
  if (!gotPrompt) {
    Serial.println("‚ùå No prompt!");
    a7670e.write(27);
    return;
  }
  
  delay(500);
  a7670e.print(msg);
  delay(500);
  a7670e.write(26);
  
  Serial.println("üì§ Waiting for confirmation...");
  String resp = "";
  start = millis();
  while (millis() - start < 30000) {
    while (a7670e.available()) {
      char c = a7670e.read();
      resp += c;
      Serial.write(c);
    }
    if (resp.indexOf("+CMGS:") >= 0) {
      Serial.println("\n‚úÖ SMS SENT!");
      return;
    }
    if (resp.indexOf("ERROR") >= 0) {
      Serial.println("\n‚ùå SMS FAILED!");
      return;
    }
  }
  Serial.println("\n‚ö†Ô∏è Timeout");
}

// ===== SETUP =====
void setup() {
  pinMode(WATER_SENSOR, INPUT);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, HIGH);
  
  Serial.begin(115200);
  delay(1000);
  
  bootTime = millis();
  
  Serial.println("\n========================================");
  Serial.println("  FLOOD DETECTION SYSTEM");
  Serial.println("========================================");
  Serial.print("Start time: ");
  Serial.println(getSystemTime());
  Serial.println("‚ö†Ô∏è Update startYear/Month/Day/Hour/Minute in code!\n");
  
  powerOnA7670E();
  
  Serial.println("üì° Initializing A7670E...");
  a7670e.begin(115200, SERIAL_8N1, A7670E_RX, A7670E_TX);
  delay(2000);
  
  a7670e.println("AT");
  waitForResponse(2000);
  
  a7670e.println("ATE0");
  waitForResponse(1000);
  
  Serial.println("\n‚è≥ Waiting for network...");
  for (int i = 0; i < 40; i++) {
    a7670e.println("AT+CREG?");
    String r = waitForResponse(1000);
    if (r.indexOf("+CREG: 0,1") >= 0 || r.indexOf("+CREG: 0,5") >= 0) {
      Serial.println("‚úÖ Network OK!");
      break;
    }
    if (i % 5 == 0) Serial.printf("Searching... %d/40\n", i);
    delay(1000);
  }
  
  a7670e.println("AT+CSQ");
  waitForResponse(2000);
  
  a7670e.println("AT+CMGF=1");
  waitForResponse(1000);
  
  a7670e.println("AT+CGPS=1");
  waitForResponse(2000);
  
  Serial.println("\nüîß Servo...");
  myServo.setPeriodHertz(50);
  myServo.attach(SERVO_PIN, 500, 2400);
  myServo.write(0);
  
  Serial.println("\n‚úÖ READY!\n");
}

// ===== LOOP =====
void loop() {
  int waterDetected = digitalRead(WATER_SENSOR);
  
  static unsigned long lastPrint = 0;
  if (!triggered && millis() - lastPrint > 10000) {
    Serial.print("üíß Water: ");
    Serial.print(waterDetected == HIGH ? "DETECTED" : "Normal");
    Serial.print(" | ");
    Serial.println(getSystemTime());
    lastPrint = millis();
  }
  
  if (waterDetected == HIGH && !triggered) {
    Serial.println("\nüö® WATER DETECTED!");
    triggered = true;
    pumpRunning = true;
    pumpStartTime = millis();
    
    digitalWrite(RELAY_PIN, LOW);
    Serial.println("üîå Pump ON (10s)");
  }
  
  if (pumpRunning && millis() - pumpStartTime >= PUMP_DURATION) {
    pumpRunning = false;
    servoRunning = true;
    servoStartTime = millis();
    
    digitalWrite(RELAY_PIN, HIGH);
    Serial.println("üîå Pump OFF");
    Serial.println("üîÑ Servo starting...");
    myServo.write(0);
  }
  
  if (servoRunning) {
    unsigned long e = millis() - servoStartTime;
    
    if (e < 2000) {
      int angle = map(e, 0, 2000, 0, 180);
      myServo.write(angle);
    } else {
      servoRunning = false;
      myServo.write(0);
      Serial.println("‚úÖ Servo done");
      
      // Get time - try network first, fallback to system
      timeStr = getNetworkTime();
      if (timeStr == "") {
        Serial.println("‚ö†Ô∏è Network time failed, using system time");
        timeStr = getSystemTime();
      } else {
        Serial.println("‚úÖ Using network time: " + timeStr);
      }
      
      // Quick GPS check
      bool hasGPS = getGPSQuick();
      
      // Build SMS
      String sms = "FLOOD ALERT!\n";
      sms += "Harness sensor detected water\n";
      sms += "Inflation: 10s\n";
      sms += "Status: UNSAFE\n";
      sms += "Time: " + timeStr + "\n";
      
      if (hasGPS) {
        sms += "Location: https://maps.google.com/?q=" + latStr + "," + lngStr;
      } else {
        sms += "Location: GPS unavailable (needs outdoors)";
      }
      
      Serial.println("\nüì± SMS:");
      Serial.println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
      Serial.println(sms);
      Serial.println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
      
      sendSMS(sms);
      
      smsSent = true;
      Serial.println("\n‚úÖ COMPLETE!\n");
    }
  }
  
  if (triggered && smsSent && waterDetected == LOW) {
    triggered = false;
    pumpRunning = false;
    servoRunning = false;
    smsSent = false;
    latStr = "";
    lngStr = "";
    timeStr = "";
    
    Serial.println("üíö System Reset\n");
  }
  
  delay(50);
}