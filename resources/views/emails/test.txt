#include <ESP32Servo.h>
#include <TinyGPS++.h>

// ===== PIN DEFINITIONS =====
#define WATER_SENSOR 27
#define RELAY_PIN    26
#define SERVO_PIN    14
#define SIM800_RX    16
#define SIM800_TX    17
#define GPS_RX       18
#define GPS_TX       19

// ===== SERIAL PORTS =====
HardwareSerial sim800(1);
HardwareSerial gpsSerial(2);
Servo myServo;
TinyGPSPlus gps;

// ===== CONFIGURATION =====
String phoneNumber = "+639070653250";

// ===== LOGIC VARIABLES =====
bool triggered = false;
bool pumpRunning = false;
bool servoRunning = false;
bool smsSent = false;
unsigned long pumpStartTime = 0;
unsigned long servoStartTime = 0;
unsigned long detectionTime = 0;
const unsigned long PUMP_DURATION = 10000;  // 10 seconds

// ===== GPS LOCATION VARIABLES =====
String latStr = "";
String lngStr = "";

// ===== HELPER FUNCTION: Wait for SIM800L response =====
void waitForResponse(int timeout = 2000) {
  unsigned long start = millis();
  while (millis() - start < timeout) {
    while (sim800.available()) {
      Serial.write(sim800.read());
    }
  }
  Serial.println();
}

// ===== GET CURRENT TIME STRING =====
String getCurrentTime() {
  // If GPS has valid time, use it and convert to Philippine Time (UTC+8)
  if (gps.time.isValid() && gps.date.isValid()) {
    // GPS provides UTC time, add 8 hours for Philippine Time
    int hour = gps.time.hour() + 8;
    int day = gps.date.day();
    int month = gps.date.month();
    int year = gps.date.year();
    
    // Handle day rollover
    if (hour >= 24) {
      hour -= 24;
      day += 1;
      
      // Days in each month (non-leap year)
      int daysInMonth[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
      
      // Check for leap year
      if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
        daysInMonth[1] = 29;  // February has 29 days in leap year
      }
      
      // Handle month rollover
      if (day > daysInMonth[month - 1]) {
        day = 1;
        month += 1;
        
        // Handle year rollover
        if (month > 12) {
          month = 1;
          year += 1;
        }
      }
    }
    
    char timeStr[40];
    sprintf(timeStr, "%02d/%02d/%04d %02d:%02d:%02d PHT", 
            month, day, year, hour, gps.time.minute(), gps.time.second());
    return String(timeStr);
  } else {
    // Use system uptime as fallback
    unsigned long seconds = detectionTime / 1000;
    unsigned long minutes = seconds / 60;
    unsigned long hours = minutes / 60;
    char timeStr[30];
    sprintf(timeStr, "Uptime: %02luh:%02lum:%02lus", 
            hours, minutes % 60, seconds % 60);
    return String(timeStr);
  }
}

// ===== SEND SMS =====
void sendSMS(String msg) {
  Serial.println("\nâ¡ï¸ Sending SMS...");
  
  // Clear any pending data
  while (sim800.available()) {
    sim800.read();
  }
  
  Serial.print("AT: ");
  sim800.println("AT");
  waitForResponse(1000);
  
  Serial.print("Set text mode: ");
  sim800.println("AT+CMGF=1");
  waitForResponse(1000);
  
  // Use IRA character set (simpler than GSM)
  Serial.print("Character set: ");
  sim800.println("AT+CSCS=\"IRA\"");
  waitForResponse(1000);
  
  Serial.print("Signal: ");
  sim800.println("AT+CSQ");
  waitForResponse(1000);
  
  Serial.print("Network: ");
  sim800.println("AT+CREG?");
  waitForResponse(2000);
  
  Serial.println("Sending SMS to: " + phoneNumber);
  sim800.println("AT+CMGS=\"" + phoneNumber + "\"");
  delay(2000);  // Increased delay
  
  // Check for '>' prompt
  bool promptReceived = false;
  unsigned long promptWait = millis();
  while (millis() - promptWait < 3000) {
    if (sim800.available()) {
      char c = sim800.read();
      Serial.write(c);
      if (c == '>') {
        promptReceived = true;
        break;
      }
    }
  }
  
  if (!promptReceived) {
    Serial.println("\nâŒ No prompt received! Aborting SMS.");
    sim800.write(27);  // Send ESC to cancel
    return;
  }
  
  Serial.println("\nâœ… Prompt received, sending message...");
  
  // Send message character by character with small delay
  for (unsigned int i = 0; i < msg.length(); i++) {
    sim800.write(msg[i]);
    delay(10);  // Small delay between characters
  }
  
  delay(500);
  
  // Send Ctrl+Z to finish
  sim800.write(26);
  Serial.println("\nğŸ“¤ Waiting for SMS delivery...");
  
  // Wait for response
  String response = "";
  unsigned long sendStart = millis();
  while (millis() - sendStart < 20000) {  // Increased timeout
    while (sim800.available()) {
      char c = sim800.read();
      response += c;
      Serial.write(c);
    }
    
    // Check if SMS was sent successfully
    if (response.indexOf("+CMGS:") >= 0) {
      Serial.println("\nâœ… SMS SENT SUCCESSFULLY!");
      return;
    } else if (response.indexOf("ERROR") >= 0) {
      Serial.println("\nâŒ SMS FAILED!");
      return;
    }
  }
  
  Serial.println("\nâš ï¸ SMS status unknown (timeout)");
}

// ===== SETUP =====
void setup() {
  pinMode(WATER_SENSOR, INPUT);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, HIGH);  // Relay OFF initially
  
  Serial.begin(115200);
  delay(1000);
  Serial.println("\n\n========================================");
  Serial.println("  FLOOD DETECTION SYSTEM + GPS");
  Serial.println("========================================\n");
  
  // Initialize GPS Module
  Serial.println("ğŸ›°ï¸ Initializing GPS...");
  gpsSerial.begin(9600, SERIAL_8N1, GPS_RX, GPS_TX);
  delay(1000);
  
  // Test GPS data flow
  Serial.println("ğŸ“¡ Testing GPS connection...");
  unsigned long gpsTest = millis();
  int charCount = 0;
  while (millis() - gpsTest < 3000) {
    while (gpsSerial.available()) {
      char c = gpsSerial.read();
      charCount++;
      gps.encode(c);
      if (charCount < 50) {
        Serial.write(c);
      }
    }
  }
  
  Serial.println();
  if (charCount > 0) {
    Serial.print("âœ… GPS module responding: ");
    Serial.print(charCount);
    Serial.println(" chars received");
    Serial.print("   Satellites detected: ");
    Serial.println(gps.satellites.value());
  } else {
    Serial.println("âŒ NO GPS DATA!");
    Serial.println("   Check wiring:");
    Serial.println("   GPS TX â†’ ESP32 GPIO18");
    Serial.println("   GPS RX â†’ ESP32 GPIO19");
    Serial.println("   GPS VCC â†’ 3.3V or 5V");
    Serial.println("   GPS GND â†’ GND");
  }
  
  Serial.println("\nâš ï¸ IMPORTANT GPS NOTES:");
  Serial.println("   â€¢ GPS needs CLEAR SKY VIEW");
  Serial.println("   â€¢ Won't work indoors");
  Serial.println("   â€¢ First fix takes 1-5 minutes outdoors");
  Serial.println("   â€¢ Keep antenna facing UP\n");
  
  // Initialize SIM800L
  Serial.println("ğŸ“¡ Initializing SIM800L...");
  sim800.begin(9600, SERIAL_8N1, SIM800_RX, SIM800_TX);
  delay(5000);
  
  Serial.print("Testing module: ");
  sim800.println("AT");
  waitForResponse(2000);
  
  Serial.print("Disable echo: ");
  sim800.println("ATE0");
  waitForResponse(1000);
  
  Serial.print("Checking SIM card: ");
  sim800.println("AT+CPIN?");
  waitForResponse(2000);
  
  Serial.println("\nâ³ Waiting for network registration...");
  bool registered = false;
  
  for (int i = 0; i < 40; i++) {
    sim800.println("AT+CREG?");
    delay(500);
    
    String response = "";
    unsigned long start = millis();
    while (millis() - start < 1000) {
      while (sim800.available()) {
        char c = sim800.read();
        response += c;
        Serial.write(c);
      }
    }
    Serial.println();
    
    if (response.indexOf("+CREG: 0,1") >= 0 || 
        response.indexOf("+CREG: 0,5") >= 0) {
      registered = true;
      Serial.println("âœ… Network registered!");
      break;
    }
    
    if (i % 5 == 0) {
      Serial.print("Still searching... (");
      Serial.print(i);
      Serial.println("/40)");
    }
    
    delay(1000);
  }
  
  if (!registered) {
    Serial.println("âš ï¸ Network registration timeout");
    Serial.println("   Check: SIM card inserted, has credit, no PIN");
  }
  
  Serial.print("\nğŸ“¶ Signal strength: ");
  sim800.println("AT+CSQ");
  waitForResponse(2000);
  Serial.println("   (Good signal: +CSQ: 10-31,0)");
  
  // Initialize Servo
  Serial.println("\nğŸ”§ Initializing servo...");
  myServo.setPeriodHertz(50);
  myServo.attach(SERVO_PIN, 500, 2400);
  myServo.write(0);  // Start at 0 degrees
  delay(500);
  
  Serial.println("\n========================================");
  Serial.println("âœ… SYSTEM READY!");
  Serial.println("========================================");
  Serial.println("Monitoring for water detection...\n");
}

// ===== LOOP =====
void loop() {
  // Feed GPS data continuously
  while (gpsSerial.available() > 0) {
    gps.encode(gpsSerial.read());
  }
  
  int waterDetected = digitalRead(WATER_SENSOR);
  
  // Status update every 5 seconds (only when not triggered)
  static unsigned long lastPrint = 0;
  if (!triggered && millis() - lastPrint > 5000) {
    Serial.print("ğŸ’§ Water: ");
    Serial.print(waterDetected == HIGH ? "âš ï¸ DETECTED" : "Normal");
    
    Serial.print(" | ğŸ›°ï¸ GPS: ");
    if (gps.location.isValid()) {
      Serial.print("âœ… FIX (");
      latStr = String(gps.location.lat(), 4);
      lngStr = String(gps.location.lng(), 4);
      Serial.print(latStr);
      Serial.print(", ");
      Serial.print(lngStr);
      Serial.print(") - ");
      Serial.print(gps.satellites.value());
      Serial.print(" sats");
    } else {
      if (gps.satellites.value() > 0) {
        Serial.print("ğŸ” ");
        Serial.print(gps.satellites.value());
        Serial.print(" sats visible, acquiring fix...");
      } else {
        Serial.print("âŒ No satellites (");
        Serial.print(gps.charsProcessed());
        Serial.print(" chars)");
      }
    }
    Serial.println();
    
    lastPrint = millis();
  }
  
  // ===== WATER DETECTION TRIGGER =====
  if (waterDetected == HIGH && !triggered) {
    Serial.println("\n");
    Serial.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Serial.println("â•‘   ğŸš¨ WATER DETECTED! ğŸš¨           â•‘");
    Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    Serial.println();
    
    triggered = true;
    pumpRunning = true;
    pumpStartTime = millis();
    detectionTime = millis();  // Record detection time
    
    // STEP 1: Activate pump
    digitalWrite(RELAY_PIN, LOW);
    Serial.println("ğŸ”Œ STEP 1: Pump ACTIVATED (10 seconds)");
    Serial.println();
  }
  
  // ===== STEP 2: After 10 seconds, turn off pump and start servo =====
  if (pumpRunning && millis() - pumpStartTime >= PUMP_DURATION) {
    pumpRunning = false;
    servoRunning = true;
    servoStartTime = millis();
    
    // Turn off pump
    digitalWrite(RELAY_PIN, HIGH);
    Serial.println("ğŸ”Œ Pump: DEACTIVATED (10 seconds complete)");
    Serial.println();
    Serial.println("ğŸ”„ STEP 2: Servo motor starting 360Â° rotation...");
    
    // Start servo rotation
    myServo.write(0);
    delay(100);
  }
  
  // ===== STEP 3: Rotate servo 360 degrees =====
  if (servoRunning) {
    unsigned long servoElapsed = millis() - servoStartTime;
    
    // Rotate servo continuously for 360 degrees
    // Assuming servo takes ~2 seconds for full rotation at continuous speed
    // Adjust timing based on your servo motor specs
    
    if (servoElapsed < 2000) {
      // Rotate servo (for continuous rotation servo, write 180 = full speed)
      // For positional servo, sweep from 0 to 180
      int angle = map(servoElapsed, 0, 2000, 0, 180);
      myServo.write(angle);
      
      // Show progress
      static unsigned long lastServoUpdate = 0;
      if (millis() - lastServoUpdate > 500) {
        Serial.print("   Servo angle: ");
        Serial.print(angle);
        Serial.println("Â°");
        lastServoUpdate = millis();
      }
    } else {
      // Servo rotation complete
      servoRunning = false;
      myServo.write(0);  // Return to start position
      Serial.println("âœ… Servo: 360Â° rotation complete");
      Serial.println();
      
      // STEP 4: Get GPS and send SMS
      Serial.println("ğŸ“ STEP 3: Getting GPS location and sending SMS...");
      Serial.println();
      
      // Build location string based on GPS availability
      String location;
      if (latStr != "" && lngStr != "") {
        location = "https://maps.google.com/?q=" + latStr + "," + lngStr;
      } else {
        location = "no location found";
      }
      
      Serial.println("DEBUG: About to call getCurrentTime()");
      String timeStr = getCurrentTime();
      Serial.println("DEBUG: getCurrentTime() returned: " + timeStr);
      
      // Build complete SMS message - use simple ASCII characters only
      String sms = "FLOOD ALERT!\n";
      sms += "Harness sensor detected water\n";
      sms += "Inflation: 10s\n";
      sms += "Status: UNSAFE\n";
      sms += "Time: " + timeStr + "\n";
      sms += "Location: " + location;
      
      // Show what we're sending
      Serial.println("\nğŸ“± SMS Content:");
      Serial.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
      Serial.println(sms);
      Serial.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
      Serial.println("Location data: " + location);
      
      Serial.println("DEBUG: About to call sendSMS()");
      // Send SMS
      sendSMS(sms);
      Serial.println("DEBUG: sendSMS() completed");
      
      smsSent = true;
      Serial.println();
      Serial.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
      Serial.println("â•‘   âœ… SEQUENCE COMPLETE!           â•‘");
      Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
      Serial.println();
    }
  }
  
  // ===== RESET WHEN WATER CLEARS =====
  if (triggered && smsSent && waterDetected == LOW) {
    triggered = false;
    pumpRunning = false;
    servoRunning = false;
    smsSent = false;
    
    // Reset location variables
    latStr = "";
    lngStr = "";
    
    Serial.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Serial.println("â•‘   ğŸ’š System Reset                  â•‘");
    Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    Serial.println("Water level normal - Ready for next detection\n");
  }
  
  delay(50);
}